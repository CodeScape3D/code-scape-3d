{
  "eslogan": "Aprende Programación de forma interactiva",
  "learn": "Aprende",
  "minigames": "Minijuegos",
  "topics": "Temáticas",
  "quizzesPageTitle": "Desafía tus conocimientos",
  "quizzesPageSubtitle": "Elije un quiz y descubre si tienes potencial como programador",
  "sortingMethods": "Métodos de Ordenamiento",
  "searchingMethods": "Métodos de búsqueda",
  "linkedLists": "Listas enlazadas",
  "binaryTrees": "Arboles binarios",
  "stacks": "Pilas",
  "queues": "Colas",
  "comingSoon": "Próximamente...",
  "next": "Siguiente",
  "previous": "Volver",
  "finish": "Finalizar",
  "correctAnswer": "Respuesta correcta!!",
  "wrongAnswer": "Respuesta incorrecta :C",
  "accept": "Acceptar",
  "uncompletedQuizText": "Debes responder todas las preguntas para finalizar el quiz",
  "correctAnswers": "Respuestas correctas",
  "wrongAnswers": "Respuestas incorrectas",
  "score": "Puntuación",
  "keepTrying": "¡Sigue intentando!",
  "endQuiz": "Finalizar quiz",
  "showAnswers": "Ver respuestas",
  "state": "Estado",
  "approved": "Aprobado",
  "failed": "Reprobado",
  "congratulations": "¡Felicidades! has aprobado el quiz de: ",
  "back": "Volver",
  "exit": "Salir",
  "seeFeedback": "Ver retroalimentación",
  "explanation": "Explicación",
  "youChoose": "Has marcado",
  "correctOption": "Respuesta correcta",
  "speedSelector": "Selector de velocidad",
  "arrayLength": "Longitud del arreglo",
  "algorithm": "Algoritmo",
  "definition": "Definition",
  "stackDefinition": "Una pila es una estructura de datos lineal que sigue el principio \"último en entrar, primero en salir\".",
  "principalOperations": "Operaciones principales",
  "pushExplanation": "Agrega un elemento en la parte superior de la pila.",
  "popExplanation": "Elimina y devuelve el elemento superior de la pila.",
  "stackUsageExplanation": "Las pilas son útiles para rastrear operaciones reversibles, y en muchos otros problemas donde se necesita acceso LIFO.",
  "utility": "Utilidad",
  "implementations": "Implementaciones",
  "stackImplementations": "Las pilas se pueden implementar utilizando arreglos (arrays) o listas enlazadas, dependiendo de las necesidades y requisitos del problema.",
  "howWorks": "Cómo funciona",
  "bubbleSortLogic": "Compara y reordena elementos adyacentes hasta que la lista esté ordenada.",
  "advantages": "Ventajas",
  "bubbleSortAdvantages": "Fácil de entender y usar, útil para listas pequeñas, requiere poca memoria extra",
  "disadvantages": "Desventajas",
  "bubbleSortDisadvantages": "Ineficiente para listas grandes, no es estable, complejidad cuadrática.",
  "complexity": "Complejidad",
  "worstCase": "Peor caso",
  "bestCase": "Mejor caso",
  "bubbleSortBestCase": "Si se añade una bandera para detectar que la lista ya está ordenada",
  "averageCase": "Caso promedio",
  "quickSortLogic": "Divide la lista en subconjuntos más pequeños y luego los ordena recursivamente",
  "quickSortAdvantages": "Eficiente en la mayoría de los casos, in situ (no requiere memoria adicional)",
  "quickSortDisadvantages": "No es estable, puede ser lento en listas casi ordenadas.",
  "quickSortWorstCase": "(raro, pero posible si se elige un pivote desfavorable): O(n^2)",
  "quickSortBestCase": "(en la mayoría de los casos): O(n log n)",
  "insertionSortLogic": "Construye una lista ordenada uno por uno insertando elementos no ordenados en su posición correcta.",
  "insertionSortAdvantages": "Simple y eficiente para listas pequeñas o casi ordenadas.",
  "insertionSortDisadvantages": "Ineficiente para listas grandes, complejidad de tiempo cuadrática.",
  "insertionSortWorstCase": "O(n^2)",
  "insertionSortBestCase": "(cuando la lista ya está casi ordenada): O(n)",
  "insertionSortAverageCase": "O(n^2)",
  "selectionSortLogic": "Encuentra el elemento mínimo y lo coloca al principio, luego repite el proceso para el resto de la lista.",
  "selectionSortAdvantages": "Simple y útil para listas pequeñas.",
  "selectionSortDisadvantages": "Ineficiente para listas grandes, no es estable, complejidad de tiempo cuadrática.",
  "selectionSortComplexity": "O(n^2), en todos los casos, ya que siempre realiza el mismo número de comparaciones y movimientos de elementos, independientemente del estado inicial de la lista.",
  "shellSortLogic": "consiste en dividir el arreglo (o la lista de elementos) en intervalos (o bloques) de varios elementos para organizarlos después por medio del ordenamiento de inserción directa.",
  "shellSortAdvantages": "Uno de los algoritmos mas rapidos, no requiere memoria adicional.",
  "shellSortDisadvantages": "Poco estable ya que pierde orden relativo, no utiliza pivote.",
  "shellSortComplexity": "La complejidad de Shell Sort depende del tipo de secuencia de incrementos que se utilice. La complejidad en el peor caso generalmente se considera entre O(n log^2 n) y O(n^2), según la secuencia de incrementos utilizada. La elección de la secuencia de incrementos puede afectar significativamente el rendimiento del algoritmo.",
  "heapSortLogic": "Construye un heap (árbol binario especial) y luego extrae el elemento máximo repetidamente para ordenar la lista.",
  "heapSortAdvantages": "Uno de los algoritmos mas rapidos, no requiere memoria adicional.",
  "heapSortDisadvantages": "No es estable, complejo, se comporta de manera ineficaz con los datos.",
  "heapSortComplexity": "O(n log n) en todos los casos. Heap Sort siempre tiene una complejidad temporal de O(n log n) en el peor caso, lo que lo hace eficiente para listas grandes.",
  "feedback": "Retroalimentación",
  "close": "Cerrar",
  "stack": "Pilas",
  "linkedlist": "Listas enlazadas",
  "insert": "Insertar",
  "delete": "Eliminar",
  "element": "Elemento"
}
