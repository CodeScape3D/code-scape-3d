{
  "eslogan": "Learn programming interactively",
  "learn": "Learn",
  "minigames": "Minigames",
  "topics": "Topics",
  "quizzesPageTitle": "Challenge your knowledge",
  "quizzesPageSubtitle": "Choose a quiz and find out if you have potential as a programmer",
  "sortingMethods": "Sorting methods",
  "searchingMethods": "Searching Methods",
  "linkedLists": "Linked Lists",
  "binaryTrees": "Binary Trees",
  "stacks": "Stacks",
  "queues": "Queues",
  "comingSoon": "Coming soon...",
  "next": "Next",
  "previous": "Previous",
  "finish": "Finish",
  "correctAnswer": "Correct answer!!",
  "wrongAnswer": "Wrong answer :C",
  "accept": "Accept",
  "uncompletedQuizText": "You must answer all the questions before finishing the quiz.",
  "correctAnswers": "Correct answers",
  "wrongAnswers": "Wrong answers",
  "score": "Score",
  "keepTrying": "Keep trying!",
  "endQuiz": "End quiz",
  "showAnswers": "Show answers",
  "state": "State",
  "approved": "Approved",
  "failed": "Failed",
  "congratulations": "Congratulations! You have passed the quiz: ",
  "back": "Back",
  "exit": "Exit",
  "seeFeedback": "See feedback",
  "explanation": "Explanation",
  "youChoose": "You have marked",
  "correctOption": "Correct option",
  "speedSelector": "Speed selector",
  "arrayLength": "Array length",
  "algorithm": "Algorithm",
  "definition": "Definition",
  "stackDefinition": "A stack is a linear data structure that follows the \"last in, first out\" principle.",
  "principalOperations": "Principal operations",
  "pushExplanation": "Adds an element to the top of the stack.",
  "popExplanation": "Removes the element at the top of the stack.",
  "stackUsageExplanation": "Stacks are useful for tracing reversible operations, and in many other problems where LIFO access is needed.",
  "utility": "Utility",
  "implementations": "Implementations",
  "stackImplementations": "Stacks can be implemented using arrays or linked lists, depending on the needs and requirements of the problem.",
  "howWorks": "How it works",
  "bubbleSortLogic": "Compares and reorders adjacent elements until the list is sorted.",
  "advantages": "Advantages",
  "bubbleSortAdvantages": "Easy to understand and use, useful for small lists, requires little extra memory",
  "disadvantages": "Disadvantages",
  "bubbleSortDisadvantages": "Inefficient for large lists, not stable, quadratic time complexity.",
  "complexity": "Complexity",
  "worstCase": "Worst case",
  "bestCase": "Best case",
  "bubbleSortBestCase": "If a flag is added to detect that the list is already sorted",
  "averageCase": "Average case",
  "quickSortLogic": "Divides the list into smaller subsets and then sorts them recursively",
  "quickSortAdvantages": "Efficient in most cases, in-place (does not require additional memory)",
  "quickSortDisadvantages": "Not stable, can be slow on nearly sorted lists.",
  "quickSortWorstCase": "(rare, but possible if an unfavorable pivot is chosen): O(n^2)",
  "quickSortBestCase": "(in most cases): O(n log n)",
  "insertionSortLogic": "Builds a sorted list one by one by inserting unsorted elements into their correct position.",
  "insertionSortAdvantages": "Simple and efficient for small or nearly sorted lists.",
  "insertionSortDisadvantages": "Inefficient for large lists, quadratic time complexity.",
  "insertionSortWorstCase": "O(n^2)",
  "insertionSortBestCase": "(when the list is nearly sorted): O(n)",
  "insertionSortAverageCase": "O(n^2)",
  "selectionSortLogic": "Finds the minimum element and places it at the beginning, then repeats the process for the rest of the list.",
  "selectionSortAdvantages": "Simple and useful for small lists.",
  "selectionSortDisadvantages": "Inefficient for large lists, not stable, quadratic time complexity.",
  "selectionSortComplexity": "O(n^2) in all cases, as it always performs the same number of comparisons and element moves, regardless of the initial state of the list.",
  "shellSortLogic": "Involves dividing the array (or list of elements) into intervals (or blocks) of several elements and then organizing them using direct insertion sort.",
  "shellSortAdvantages": "One of the fastest algorithms, does not require additional memory.",
  "shellSortDisadvantages": "Somewhat unstable as it loses relative order, does not use a pivot.",
  "shellSortComplexity": "The complexity of Shell Sort depends on the type of increment sequence used. The worst-case complexity is generally considered to be between O(n log^2 n) and O(n^2), depending on the increment sequence used. The choice of the increment sequence can significantly affect the algorithm's performance.",
  "heapSortLogic": "Builds a heap (special binary tree) and then repeatedly extracts the maximum element to sort the list.",
  "heapSortAdvantages": "One of the fastest algorithms, does not require additional memory.",
  "heapSortDisadvantages": "Not stable, complex, can behave inefficiently with data.",
  "heapSortComplexity": "O(n log n) in all cases. Heap Sort always has a time complexity of O(n log n) in the worst case, making it efficient for large lists.",
  "feedback": "Feedback",
  "close": "Close"
}
